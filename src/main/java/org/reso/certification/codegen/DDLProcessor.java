package org.reso.certification.codegen;

import com.google.common.base.CaseFormat;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.reso.commander.common.Utils;
import org.reso.models.ReferenceStandardField;

//TODO: move to central lib
import static org.reso.certification.codegen.EDMXProcessor.EMPTY_STRING;
import static org.reso.certification.containers.WebAPITestContainer.SINGLE_SPACE;

import static org.reso.commander.common.DataDictionaryMetadata.v1_7.*;

public class DDLProcessor extends WorksheetProcessor {
  private static final Logger LOG = LogManager.getLogger(DDLProcessor.class);
  private static final String PADDING = "  ";
  private static final int STRING_KEY_SIZE = 64;

  private final boolean useKeyNumeric;

  public DDLProcessor() {
    this.useKeyNumeric = false;
  }

  public DDLProcessor(boolean useKeyNumeric) {
    this.useKeyNumeric = useKeyNumeric;
  }

  private String buildFieldMarkup(String fieldName, String typeMarkup) {
    StringBuilder fieldMarkup = new StringBuilder();

    if (markup.length() > 0) {
      fieldMarkup.append(", ");
    }

    fieldMarkup.append("\n")
      .append(PADDING)
      .append(fieldName)
      .append(SINGLE_SPACE)
      .append(typeMarkup);

    //if the current field is a key field then append NOT NULL depending on which key it is
    if ((useKeyNumeric && isPrimaryKeyNumericField(sheet.getSheetName(), fieldName))) {
      fieldMarkup.append(SINGLE_SPACE).append("NOT NULL AUTO_INCREMENT");
    } else if (isPrimaryKeyField(sheet.getSheetName(), fieldName)) {
      fieldMarkup.append(SINGLE_SPACE).append("NOT NULL");
    } else if (!typeMarkup.contains("DEFAULT")) {
      fieldMarkup.append(SINGLE_SPACE).append("DEFAULT NULL");
    }

    return fieldMarkup.toString();
  }

  private String buildPrimaryKeyMarkup(String resourceName) {
    return "PRIMARY KEY (" +
        (useKeyNumeric ? getKeyNumericFieldForResource(resourceName) : getKeyFieldForResource(resourceName)) + ")";
  }

  @Override
  void processNumber(ReferenceStandardField field) {
    String typeMarkup = "";

    if (field.getSuggestedMaxPrecision() != null) {
      //omitting the length and precision attributes as described here in order to maximize cross-platform compatibility.
      //https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html#:~:text=A%20precision%20from%2024%20to,be%20after%20the%20decimal%20point
      typeMarkup += "DOUBLE PRECISION";
    } else {
      if (Math.pow(2, field.getSuggestedMaxLength()) <= Math.pow(2, 16) - 1) {
        //TINYINT
        typeMarkup += "TINYINT";
      } else if (Math.pow(2, field.getSuggestedMaxLength()) <= Math.pow(2, 32) - 1) {
        typeMarkup += "INTEGER";
      } else {
        typeMarkup += "BIGINT";
      }
    }

    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processStringListSingle(ReferenceStandardField field) {
    String typeMarkup = useKeyNumeric ? "BIGINT" : "VARCHAR(" + STRING_KEY_SIZE + ")";
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processString(ReferenceStandardField field) {
    String typeMarkup = !field.getStandardName().contains("Key") && field.getSuggestedMaxLength() > 80 ? "TEXT":
        "VARCHAR" + (field.getSuggestedMaxLength() != null ? "(" + field.getSuggestedMaxLength() + ")" : EMPTY_STRING);
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processBoolean(ReferenceStandardField field) {
    String typeMarkup = "TINYINT(1) DEFAULT FALSE";
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processStringListMulti(ReferenceStandardField field) {
    String typeMarkup = useKeyNumeric ? "BIGINT" : "VARCHAR(" + STRING_KEY_SIZE + ")";
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processDate(ReferenceStandardField field) {
    String typeMarkup = "DATE";
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processTimestamp(ReferenceStandardField field) {
    String typeMarkup = "DATETIME";
    markup.append(buildFieldMarkup(field.getStandardName(), typeMarkup));
  }

  @Override
  void processCollection(ReferenceStandardField field) {
    //NOTE: NOT IMPLEMENTED FOR DDL CREATION SCRIPTS
    //A Collection is actually a list of known values from a joined resource
    //this is handled by StandardResources
  }

  @Override
  void generateOutput() {
    StringBuilder content = new StringBuilder();

    content
      .append("/**\n")
      .append(PADDING).append("RESO Data Dictionary 1.7 Database Generation (DDL) Script\n")
      .append(PADDING).append("Autogenerated on: ").append(Utils.getIsoTimestamp()).append("\n")
      .append(PADDING).append("This content is covered by RESO's EULA. SEE: https://www.reso.org/eula/\n")
      .append(PADDING).append("For questions or comments, please contact dev@reso.org\n")
      .append("**/\n\n");

    content.append("CREATE DATABASE IF NOT EXISTS reso_data_dictionary_1_7;\n");
    content.append("USE reso_data_dictionary_1_7;");

    resourceTemplates.forEach((resourceName, templateContent) -> {
      content
          .append("\n\n")
          .append("CREATE TABLE IF NOT EXISTS ")
          //exception for ouid so it doesn't become o_u_i_d
          .append(CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, resourceName).replace("o_u_i_d", "ouid"))
          .append(" ( ")
          .append(templateContent).append(",\n")
          .append(PADDING).append(PADDING).append(buildPrimaryKeyMarkup(resourceName)).append("\n")
          .append(") ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    });

    LOG.info(sanitizeSql(content.toString()));
  }

  /**
   * Add treatments for any SQL replacements that need to be done here
   *
   * For instance, 'Order' is used by the DD in the Media resource, but it's a SQL keyword.
   * @param sql SQL statement to be sanitized
   * @return sanitized SQL statement
   */
  private static String sanitizeSql(String sql) {
    return sql
        .replaceAll("\\bOrder\\b", "'Order'");
  }

}
